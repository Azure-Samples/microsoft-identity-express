{"version":3,"file":"microsoft-identity-express.cjs.production.min.js","sources":["../src/utils/Constants.ts","../src/config/AppSettings.ts","../src/config/ConfigHelper.ts","../src/client/BaseAuthClientBuilder.ts","../src/utils/CryptoUtils.ts","../src/client/BaseAuthClient.ts","../src/packageMetadata.ts","../src/network/FetchManager.ts","../src/utils/UrlUtils.ts","../src/client/webapp/MsalWebAppAuthClient.ts","../src/client/webapp/AppServiceWebAppAuthClient.ts","../src/network/KeyVaultManager.ts","../src/config/MsalConfiguration.ts","../src/utils/EnvironmentUtils.ts","../src/client/webapp/WebAppAuthClientBuilder.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { LoggerOptions, LogLevel } from '@azure/msal-common';\n\n/**\n * Basic authentication stages used to determine\n * appropriate action after redirect occurs\n */\nexport enum AppStages {\n  SIGN_IN = 'sign_in',\n  SIGN_OUT = 'sign_out',\n  ACQUIRE_TOKEN = 'acquire_token',\n}\n\n/**\n * String constants related to AAD Authority\n */\nexport const AADAuthorityConstants = {\n  COMMON: 'common',\n  ORGANIZATIONS: 'organizations',\n  CONSUMERS: 'consumers',\n};\n\n/**\n * String constants related credential type\n */\nexport enum KeyVaultCredentialTypes {\n  SECRET = 'clientSecret',\n  CERTIFICATE = 'clientCertificate',\n}\n\nexport const OIDC_SCOPES = ['openid', 'profile', 'email', 'offline_access'];\n\n/**\n * Request headers used by App Service authentication\n */\nexport const AppServiceAuthenticationHeaders = {\n  APP_SERVICE_AUTHENTICATION_HEADER: 'X-MSAL-APP-SERVICE-AUTHENTICATION',\n  APP_SERVICE_ACCESS_TOKEN_HEADER: 'X-MS-TOKEN-AAD-ACCESS-TOKEN',\n  APP_SERVICE_ID_TOKEN_HEADER: 'X-MS-TOKEN-AAD-ID-TOKEN',\n  APP_SERVICE_REFRESH_TOKEN_HEADER: 'X-MS-TOKEN-AAD-REFRESH-TOKEN',\n  APP_SERVICE_ACCESS_TOKEN_EXPIRES_HEADER: 'X-MS-TOKEN-AAD-EXPIRES-ON',\n  APP_SERVICE_USER_OID_HEADER: 'X-MS-CLIENT-PRINCIPAL-ID',\n  APP_SERVICE_USER_UPN_HEADER: 'X-MS-CLIENT-PRINCIPAL-NAME',\n  APP_SERVICE_IDP_X_HEADER: 'X-MS-CLIENT-PRINCIPAL-IDP',\n};\n\n/**\n * Endpoints used by App Service authentication\n */\nexport const AppServiceAuthenticationEndpoints = {\n  ID_TOKEN_ENDPOINT: '/.auth/me',\n  POST_LOGOUT_DEFAULT_ENDPOINT: '/.auth/logout/done',\n  POST_LOGIN_DEFAULT_ENDPOINT: '/.auth/login/done',\n  AAD_SIGN_IN_ENDPOINT: '/.auth/login/aad',\n  AAD_SIGN_OUT_ENDPOINT: '/.auth/logout',\n  TOKEN_REFRESH_ENDPOINT: '/.auth/refresh',\n  AAD_REDIRECT_ENDPOINT: '/.auth/login/aad/callback',\n};\n\n/**\n * Query parameters used by App Service authentication endpoints\n */\nexport const AppServiceAuthenticationQueryParameters = {\n  POST_LOGIN_REDIRECT_QUERY_PARAM: '?post_login_redirect_url=',\n  POST_LOGOUT_REDIRECT_QUERY_PARAM: '?post_logout_redirect_uri=',\n};\n\n/**\n * Environment variables used by App Service authentication\n */\nexport const AppServiceEnvironmentVariables = {\n  WEBSITE_AUTH_ENABLED: 'WEBSITE_AUTH_ENABLED',\n  WEBSITE_AUTH_ALLOWED_AUDIENCES: 'WEBSITE_AUTH_ALLOWED_AUDIENCES',\n  WEBSITE_AUTH_DEFAULT_PROVIDER: 'WEBSITE_AUTH_DEFAULT_PROVIDER',\n  WEBSITE_AUTH_TOKEN_STORE: 'WEBSITE_AUTH_TOKEN_STORE',\n  WEBSITE_AUTH_LOGIN_PARAMS: 'WEBSITE_AUTH_LOGIN_PARAMS',\n  WEBSITE_AUTH_PRESERVE_URL_FRAGMENT: 'WEBSITE_AUTH_PRESERVE_URL_FRAGMENT',\n  WEBSITE_AUTH_OPENID_ISSUER: 'WEBSITE_AUTH_OPENID_ISSUER',\n  WEBSITE_AUTH_CLIENT_ID: 'WEBSITE_AUTH_CLIENT_ID',\n  WEBSITE_HOSTNAME: 'WEBSITE_HOSTNAME',\n  WEBSITE_SITE_NAME: 'WEBSITE_SITE_NAME',\n  WEBSITE_AUTH_REQUIRE_HTTPS: 'WEBSITE_AUTH_REQUIRE_HTTPS',\n  WEBSITE_AUTH_UNAUTHENTICATED_ACTION: 'WEBSITE_AUTH_UNAUTHENTICATED_ACTION',\n  WEBSITE_AUTH_API_PREFIX: 'WEBSITE_AUTH_API_PREFIX',\n  MICROSOFT_PROVIDER_AUTHENTICATION_SECRET:\n    'MICROSOFT_PROVIDER_AUTHENTICATION_SECRET',\n};\n\n/**\n * Constants used in access control scenarios\n */\nexport const AccessControlConstants = {\n  GROUPS: 'groups',\n  ROLES: 'roles',\n  CLAIM_NAMES: '_claim_name',\n  CLAIM_SOURCES: '_claim_sources',\n  PAGINATION_LINK: '@odata.nextLink',\n  GRAPH_MEMBERS_ENDPOINT: 'https://graph.microsoft.com/v1.0/me/memberOf',\n  GRAPH_MEMBER_SCOPES: 'User.Read GroupMember.Read.All',\n};\n\n/**\n * Various information constants\n */\nexport const InfoMessages = {\n  APP_SERVICE_AUTH_DETECTED: 'App Service Authentication detected',\n  REQUEST_FOR_RESOURCE: 'Request made to web API',\n  OVERAGE_OCCURRED: 'User has too many groups. Groups overage claim occurred',\n};\n\n/**\n * Various error constants\n */\nexport const ErrorMessages = {\n  NOT_PERMITTED: 'Not permitted',\n  INVALID_TOKEN: 'Invalid token',\n  CANNOT_DETERMINE_APP_STAGE: 'Cannot determine application stage',\n  CANNOT_VALIDATE_TOKEN: 'Cannot validate token',\n  CSRF_TOKEN_MISMATCH:\n    'CSRF token in response does not match to original request',\n  INTERACTION_REQUIRED: 'interaction_required',\n  TOKEN_ACQUISITION_FAILED: 'Token acquisition failed',\n  TOKEN_RESPONSE_NULL: 'Token response is null',\n  AUTH_CODE_URL_NOT_OBTAINED: 'Authorization code url cannot be obtained',\n  TOKEN_NOT_FOUND: 'No token found',\n  TOKEN_NOT_DECODED: 'Token cannot be decoded',\n  TOKEN_NOT_VERIFIED: 'Token cannot be verified',\n  KEYS_NOT_OBTAINED: 'Signing keys cannot be obtained',\n  STATE_NOT_FOUND: 'State not found',\n  USER_HAS_NO_ROLE: 'User does not have any roles',\n  USER_NOT_IN_ROLE: 'User does not have this role',\n  USER_HAS_NO_GROUP: 'User does not have any groups',\n  USER_NOT_IN_GROUP: 'User does not have this group',\n  METHOD_NOT_ALLOWED: 'Method not allowed for this route',\n  RULE_NOT_FOUND: 'No rule found for this route',\n  SESSION_NOT_FOUND: 'No session found for this request',\n  KEY_VAULT_CONFIG_NOT_FOUND: 'No coordinates found for Key Vault',\n  CANNOT_OBTAIN_CREDENTIALS_FROM_KEY_VAULT:\n    'Cannot obtain credentials from Key Vault',\n  SESSION_KEY_NOT_FOUND:\n    'No session key found in session. Cannot encrypt state data',\n  AUTH_CODE_REQUEST_OBJECT_NOT_FOUND:\n    'No auth code request object found in session',\n  ID_TOKEN_CLAIMS_NOT_FOUND: 'No id token claims found in session',\n};\n\n/**\n * Various configuration error constants\n */\nexport const ConfigurationErrorMessages = {\n  AUTH_ROUTES_NOT_CONFIGURED:\n    'Authentication routes are not defined. Ensure that the application settings are configured properly.',\n  NO_PROTECTED_RESOURCE_CONFIGURED:\n    'No protected resource is configured to acquire a token for. Ensure that the application settings are configured properly.',\n  NO_ACCESS_MATRIX_CONFIGURED:\n    'No access matrix is configured to control access for. Ensure that the application settings are configured properly.',\n  NO_CLIENT_ID: 'No clientId provided!',\n  INVALID_CLIENT_ID: 'Invalid clientId!',\n  NO_TENANT_INFO: 'No tenant info provided!',\n  INVALID_TENANT_INFO: 'Invalid tenant info!',\n  NO_CLIENT_CREDENTIAL: 'No client credential provided!',\n  NO_REDIRECT_URI: 'No redirect URI provided!',\n  NO_UNAUTHORIZED_ROUTE: 'No unauthorized route provided!',\n};\n\n/**\n * For more information, visit: https://login.microsoftonline.com/error\n */\nexport const ErrorCodes = {\n  65001: 'AADSTS65001', // consent required\n  50076: 'AADSTS50076', // mfa required\n  50079: 'AADSTS50079', // mfa enrollment required\n  50001: 'AADSTS50001', // invalid resource uri\n  65004: 'AADSTS65004', // user declined consent\n  70011: 'AADSTS70011', // invalid scope\n  700022: 'AADSTS700022', // multiple resources\n  700020: 'AADSTS700020', // interaction required\n  90118: 'AADB2C90118', // password forgotten (B2C)\n};\n\nexport const DEFAULT_LOGGER_OPTIONS: LoggerOptions = {\n  loggerCallback: (logLevel, message, containsPii) => {\n    if (containsPii) {\n      return;\n    }\n    console.info(message);\n  },\n  piiLoggingEnabled: false,\n  logLevel: LogLevel.Info,\n};\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { LoggerOptions } from '@azure/msal-common';\n\nexport type AppSettings = {\n    appCredentials: AppCredentials;\n    authRoutes?: AuthRoutes;\n    loggerOptions?: LoggerOptions;\n    b2cPolicies?: {\n        [policy: string]: Policy;\n    };\n    accessMatrix?: {\n        [accessRule: string]: AccessRule;\n    };\n    protectedResources?: {\n        [resource: string]: Resource;\n    };\n    ownedResources?: {\n        [resource: string]: Resource;\n    };\n};\n\nexport type AppCredentials = {\n    instance?: string;\n    clientId: string;\n    tenantId: string;\n    clientSecret?: string;\n    clientCertificate?: ClientCertificate;\n};\n\nexport type ClientCertificate = {\n    thumbprint: string;\n    privateKey: string;\n    x5c?: string;\n};\n\nexport type KeyVaultCredential = {\n    credentialType: string;\n    credentialName: string;\n    keyVaultUrl: string;\n};\n\nexport type AuthRoutes = {\n    redirect: string;\n    unauthorized: string;\n    frontChannelLogout?: string;\n};\n\nexport type Policy = {\n    authority: string;\n};\n\nexport type Resource = {\n    endpoint: string;\n    scopes: string[];\n    accessToken?: string;\n};\n\nexport type AccessRule = {\n    path: string;\n    methods: string[];\n    roles?: string[];\n    groups?: string[];\n};\n\nexport enum AppType {\n    WebApp,\n    WebApi,\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { StringUtils } from '@azure/msal-common';\n\nimport {\n    AADAuthorityConstants,\n    ConfigurationErrorMessages,\n    OIDC_SCOPES,\n} from '../utils/Constants';\nimport { AppSettings, AppType, Resource } from './AppSettings';\n\nexport class ConfigHelper {\n    /**\n     * Validates the fields in the configuration file\n     * @param {AppSettings} appSettings: configuration object\n     * @returns {void}\n     */\n    static validateAppSettings(appSettings: AppSettings, appType: AppType): void {\n        if (StringUtils.isEmpty(appSettings.appCredentials.clientId)) {\n            throw new Error(ConfigurationErrorMessages.NO_CLIENT_ID);\n        } else if (!ConfigHelper.isGuid(appSettings.appCredentials.clientId)) {\n            throw new Error(ConfigurationErrorMessages.INVALID_CLIENT_ID);\n        }\n\n        if (StringUtils.isEmpty(appSettings.appCredentials.tenantId)) {\n            throw new Error(ConfigurationErrorMessages.NO_TENANT_INFO);\n        } else if (\n            !ConfigHelper.isGuid(appSettings.appCredentials.tenantId) &&\n            !Object.values(AADAuthorityConstants).includes(\n                appSettings.appCredentials.tenantId\n            )\n        ) {\n            throw new Error(ConfigurationErrorMessages.INVALID_TENANT_INFO);\n        }\n\n        switch (appType) {\n            case AppType.WebApp:\n                if (StringUtils.isEmpty(appSettings.authRoutes?.redirect)) {\n                    throw new Error(ConfigurationErrorMessages.NO_REDIRECT_URI);\n                }\n\n                if (StringUtils.isEmpty(appSettings.authRoutes?.unauthorized)) {\n                    throw new Error(ConfigurationErrorMessages.NO_UNAUTHORIZED_ROUTE);\n                }\n\n                break;\n            case AppType.WebApi:\n                break;\n            default:\n                break;\n        }\n    }\n\n    /**\n     * Verifies if a string is GUID\n     * @param {string} guid\n     * @returns {boolean}\n     */\n    static isGuid(guid: string): boolean {\n        const regexGuid =\n            /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n        return regexGuid.test(guid);\n    }\n\n    /**\n     * Util method to get the resource name for a given scope(s)\n     * @param {Array} scopes: an array of scopes that the resource is associated with\n     * @param {AppSettings} appSettings: application authentication parameters\n     * @returns {string}\n     */\n    static getResourceNameFromScopes(\n        scopes: string[],\n        appSettings: AppSettings\n    ): string {\n        const index = Object.values({\n            ...appSettings.protectedResources,\n            ...appSettings.ownedResources,\n        }).findIndex(\n            (resource: Resource) =>\n                JSON.stringify(resource.scopes) === JSON.stringify(scopes)\n        );\n\n        const resourceName = Object.keys({\n            ...appSettings.protectedResources,\n            ...appSettings.ownedResources,\n        })[index];\n\n        return resourceName;\n    }\n\n    /**\n     * Util method to get the scopes for a given resource name\n     * @param {string} resourceEndpoint: the resource name\n     * @param {AppSettings} appSettings: application authentication parameters\n     * @returns {string}\n     */\n    static getScopesFromResourceEndpoint(\n        resourceEndpoint: string,\n        appSettings: AppSettings\n    ): string[] {\n        const scopes = Object.values({\n            ...appSettings.protectedResources,\n            ...appSettings.ownedResources,\n        }).find(\n            (resource: Resource) => resource.endpoint === resourceEndpoint\n        )?.scopes;\n\n        return scopes ? scopes : [];\n    }\n\n    /**\n     * Util method to strip the default OIDC scopes from the scopes array\n     * @param {Array} scopesList full list of scopes for this resource\n     * @returns\n     */\n    static getEffectiveScopes(scopesList: string[]): string[] {\n        const effectiveScopesList = scopesList.filter(\n            (scope) => !OIDC_SCOPES.includes(scope)\n        );\n        return effectiveScopesList;\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ICachePlugin } from '@azure/msal-node';\n\nimport { ConfigHelper } from '../config/ConfigHelper';\nimport {\n    AppSettings,\n    AppType,\n    KeyVaultCredential,\n} from '../config/AppSettings';\n\nexport abstract class BaseAuthClientBuilder {\n    appSettings: AppSettings;\n    protected keyVaultCredential: KeyVaultCredential | undefined;\n    protected customCachePlugin: ICachePlugin | undefined;\n\n    protected constructor(appSettings: AppSettings, appType: AppType) {\n        ConfigHelper.validateAppSettings(appSettings, appType);\n        this.appSettings = appSettings;\n    }\n\n    withKeyVaultCredentials(\n        keyVaultCredential: KeyVaultCredential\n    ): BaseAuthClientBuilder {\n        this.keyVaultCredential = keyVaultCredential;\n        return this;\n    }\n\n    withCustomCachePlugin(cachePlugin: ICachePlugin): BaseAuthClientBuilder {\n        this.customCachePlugin = cachePlugin;\n        return this;\n    }\n\n    abstract build(): any;\n\n    abstract buildAsync(): Promise<any>;\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as crypto from 'crypto';\n\nexport class CryptoUtils {\n  private algorithm: string;\n\n  constructor(algorithm: string = 'aes-192-cbc') {\n    this.algorithm = algorithm;\n  }\n\n  generateSalt(): string {\n    return crypto.randomBytes(20).toString('hex');\n  }\n\n  createKey(password: string, salt: string): Buffer {\n    return crypto.scryptSync(password, salt, 24);\n  }\n\n  encryptData(stringifiedData: string, key: Buffer): string {\n    const iv = crypto.randomBytes(16);\n    const cipher = crypto.createCipheriv(this.algorithm, key, iv);\n    const encryptedData = cipher.update(stringifiedData, 'utf8', 'hex');\n\n    return [iv.toString('hex'), encryptedData + cipher.final('hex')].join('.');\n  }\n\n  decryptData(encryptedData: string, key: Buffer): string {\n    const [iv, encrypted] = encryptedData.split('.');\n    const decipher = crypto.createDecipheriv(\n      this.algorithm,\n      key,\n      Buffer.from(iv, 'hex')\n    );\n    return decipher.update(encrypted, 'hex', 'utf8') + decipher.final('utf8');\n  }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Logger } from '@azure/msal-common';\n\nimport {\n    ConfidentialClientApplication,\n    Configuration,\n    CryptoProvider,\n} from '@azure/msal-node';\n\nimport { AppSettings } from '../config/AppSettings';\n\nimport { packageName, packageVersion } from '../packageMetadata';\nimport { CryptoUtils } from '../utils/CryptoUtils';\n\nexport abstract class BaseAuthClient {\n    appSettings: AppSettings;\n\n    protected msalConfig: Configuration;\n    protected msalClient: ConfidentialClientApplication;\n    protected cryptoProvider: CryptoProvider;\n    protected cryptoUtils: CryptoUtils;\n    protected logger: Logger;\n\n    protected constructor(appSettings: AppSettings, msalConfig: Configuration) {\n        this.appSettings = appSettings;\n        this.msalConfig = msalConfig;\n        this.cryptoProvider = new CryptoProvider();\n        this.cryptoUtils = new CryptoUtils();\n\n        this.logger = new Logger(\n            this.msalConfig.system?.loggerOptions!,\n            packageName,\n            packageVersion\n        );\n\n        this.msalClient = new ConfidentialClientApplication(this.msalConfig);\n    }\n\n    getMsalClient(): ConfidentialClientApplication {\n        return this.msalClient;\n    }\n\n    getMsalConfig(): Configuration {\n        return this.msalConfig;\n    }\n\n    getLogger(): Logger {\n        return this.logger;\n    }\n}\n","export const packageName = '@azure-samples/microsoft-identity-express';\nexport const packageVersion = 'beta';\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport axios, { AxiosResponse, AxiosRequestConfig } from 'axios';\nimport { StringUtils } from '@azure/msal-common';\n\nimport { AccessControlConstants, ErrorMessages } from '../utils/Constants';\n\nexport class FetchManager {\n    /**\n     * Calls a resource endpoint\n     * @param {string} endpoint\n     * @returns {Promise}\n     */\n    static callApiEndpoint = async (endpoint: string): Promise<AxiosResponse> => {\n        try {\n            const response: AxiosResponse = await axios.get(endpoint);\n            return response.data;\n        } catch (error) {\n            throw error;\n        }\n    };\n\n    /**\n     * Calls a resource endpoint with a raw access token\n     * using the authorization bearer token scheme\n     * @param {string} endpoint\n     * @param {string} accessToken\n     * @returns {Promise}\n     */\n    static callApiEndpointWithToken = async (\n        endpoint: string,\n        accessToken: string\n    ): Promise<AxiosResponse<any>> => {\n        if (StringUtils.isEmpty(accessToken)) {\n            throw new Error(ErrorMessages.TOKEN_NOT_FOUND);\n        }\n\n        const options: AxiosRequestConfig = {\n            headers: {\n                Authorization: `Bearer ${accessToken}`,\n            },\n        };\n\n        try {\n            const response: AxiosResponse = await axios.get(endpoint, options);\n            return response.data;\n        } catch (error) {\n            throw error;\n        }\n    };\n\n    /**\n     * Handles queries against Microsoft Graph that return multiple pages of data\n     * @param {string} accessToken: access token required by endpoint\n     * @param {string} nextPage: next page link\n     * @param {Array} data: stores data from each page\n     * @returns {Promise}\n     */\n    static handlePagination = async (\n        accessToken: string,\n        nextPage: string,\n        data: string[] = []\n    ): Promise<string[]> => {\n        try {\n            const graphResponse = await (\n                await FetchManager.callApiEndpointWithToken(nextPage, accessToken)\n            ).data;\n            graphResponse['value'].map((v: any) => data.push(v.id));\n\n            if (graphResponse[AccessControlConstants.PAGINATION_LINK]) {\n                return await FetchManager.handlePagination(\n                    accessToken,\n                    graphResponse[AccessControlConstants.PAGINATION_LINK],\n                    data\n                );\n            } else {\n                return data;\n            }\n        } catch (error) {\n            throw error;\n        }\n    };\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Request } from 'express';\nimport { IUri, UrlString } from '@azure/msal-common';\n\nexport class UrlUtils {\n  /**\n   * Gets the absolute URL from a given request and path string\n   * @param {Request} req: express request object\n   * @param {string} url: a given URL\n   * @returns {string}\n   */\n  static ensureAbsoluteUrl = (req: Request, url: string): string => {\n    const urlComponents: IUri = new UrlString(url).getUrlComponents();\n\n    if (!urlComponents.Protocol) {\n      if (!urlComponents.HostNameAndPort && !url.startsWith('www')) {\n        if (!url.startsWith('/')) {\n          return req.protocol + '://' + req.get('host') + '/' + url;\n        }\n        return req.protocol + '://' + req.get('host') + url;\n      }\n      return req.protocol + '://' + url;\n    } else {\n      return url;\n    }\n  };\n\n  /**\n   * Gets the path segment from a given URL\n   * @param {string} url: a given URL\n   * @returns {string}\n   */\n  static getPathFromUrl = (url: string): string => {\n    const urlComponents: IUri = new UrlString(url).getUrlComponents();\n    return `/${urlComponents.PathSegments.join('/')}`;\n  };\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport express, {\n  RequestHandler,\n  Request,\n  Response,\n  NextFunction,\n  Router,\n} from 'express';\n\nimport {\n  OIDC_DEFAULT_SCOPES,\n  InteractionRequiredAuthError,\n  StringUtils,\n  ResponseMode,\n} from '@azure/msal-common';\n\nimport {\n  AuthorizationCodeRequest,\n  AuthorizationUrlRequest,\n  Configuration,\n  SilentFlowRequest,\n} from '@azure/msal-node';\n\nimport { BaseAuthClient } from '../BaseAuthClient';\nimport { ConfigHelper } from '../../config/ConfigHelper';\nimport { FetchManager } from '../../network/FetchManager';\nimport { UrlUtils } from '../../utils/UrlUtils';\n\nimport { Resource, AppSettings, AccessRule } from '../../config/AppSettings';\n\nimport {\n  TokenRequestOptions,\n  GuardOptions,\n  SignInOptions,\n  SignOutOptions,\n} from '../MiddlewareOptions';\n\nimport {\n  AppStages,\n  ErrorMessages,\n  AccessControlConstants,\n  ConfigurationErrorMessages,\n} from '../../utils/Constants';\n\nimport { AppState } from '../../utils/Types';\n\n/**\n * A simple wrapper around MSAL Node ConfidentialClientApplication object.\n * It offers a collection of middleware and utility methods that automate\n * basic authentication and authorization tasks in Express web apps\n */\nexport class MsalWebAppAuthClient extends BaseAuthClient {\n  /**\n   * @param {AppSettings} appSettings\n   * @param {Configuration} msalConfig\n   * @constructor\n   */\n  constructor(appSettings: AppSettings, msalConfig: Configuration) {\n    super(appSettings, msalConfig);\n  }\n\n  /**\n   * Initialize AuthProvider and set default routes and handlers\n   * @returns {Router}\n   */\n  initialize(): Router {\n    if (!this.appSettings.authRoutes) {\n      this.logger.error(ConfigurationErrorMessages.AUTH_ROUTES_NOT_CONFIGURED);\n      throw new Error(ConfigurationErrorMessages.AUTH_ROUTES_NOT_CONFIGURED);\n    }\n\n    const appRouter = express.Router();\n\n    appRouter.use((req: Request, res: Response, next: NextFunction) => {\n      if (!req.session) {\n        this.logger.error(ErrorMessages.SESSION_NOT_FOUND);\n        throw new Error(ErrorMessages.SESSION_NOT_FOUND);\n      }\n\n      next();\n    });\n\n    appRouter.post(\n      UrlUtils.getPathFromUrl(this.appSettings.authRoutes.redirect),\n      this.handleRedirect()\n    );\n\n    if (this.appSettings.authRoutes?.frontChannelLogout) {\n      /**\n       * Expose front-channel logout route. For more information, visit:\n       * https://docs.microsoft.com/azure/active-directory/develop/v2-protocols-oidc#single-sign-out\n       */\n      appRouter.get(\n        this.appSettings.authRoutes.frontChannelLogout,\n        (req: Request, res: Response) => {\n          req.session.destroy(() => {\n            res.sendStatus(200);\n          });\n        }\n      );\n    }\n\n    return appRouter;\n  }\n\n  /**\n   * Initiates sign in flow\n   * @param {SignInOptions} options: options to modify login request\n   * @returns {RequestHandler}\n   */\n  signIn(\n    options: SignInOptions = {\n      postLoginRedirect: '/',\n      failureRedirect: '/',\n    }\n  ): RequestHandler {\n    return (req: Request, res: Response, next: NextFunction): Promise<void> => {\n      const customState = {\n        appStage: AppStages.SIGN_IN,\n        redirectTo: options.postLoginRedirect,\n        csrfToken: req.session.csrfToken,\n      } as AppState;\n\n      const authUrlParams = {\n        scopes: OIDC_DEFAULT_SCOPES,\n      } as AuthorizationUrlRequest;\n\n      const authCodeParams = {\n        scopes: OIDC_DEFAULT_SCOPES,\n      } as AuthorizationCodeRequest;\n\n      // get url to sign user in\n      return this.redirectToAuthCodeUrl(\n        req,\n        res,\n        next,\n        authUrlParams,\n        authCodeParams,\n        customState\n      );\n    };\n  }\n\n  /**\n   * Initiate sign out and destroy the session\n   * @param {SignOutOptions} options: options to modify logout request\n   * @returns {RequestHandler}\n   */\n  signOut(\n    options: SignOutOptions = {\n      postLogoutRedirect: '/',\n    }\n  ): RequestHandler {\n    return (req: Request, res: Response): void => {\n      const postLogoutRedirectUri = UrlUtils.ensureAbsoluteUrl(\n        req,\n        options.postLogoutRedirect\n      );\n\n      /**\n       * Construct a logout URI and redirect the user to end the\n       * session with Azure AD/B2C. For more information, visit:\n       * (AAD) https://docs.microsoft.com/azure/active-directory/develop/v2-protocols-oidc#send-a-sign-out-request\n       * (B2C) https://docs.microsoft.com/azure/active-directory-b2c/openid-connect#send-a-sign-out-request\n       */\n      const logoutUri = `${this.msalConfig.auth.authority}/oauth2/v2.0/logout?post_logout_redirect_uri=${postLogoutRedirectUri}`;\n\n      req.session.destroy(() => {\n        res.redirect(logoutUri);\n      });\n    };\n  }\n\n  /**\n   * Middleware that handles redirect depending on request state\n   * There are basically 2 stages: sign-in and acquire token\n   * @returns {RequestHandler}\n   */\n  private handleRedirect(): RequestHandler {\n    return async (\n      req: Request,\n      res: Response,\n      next: NextFunction\n    ): Promise<void> => {\n      if (!req.session.key) {\n        this.logger.error(ErrorMessages.SESSION_NOT_FOUND);\n        throw new Error(ErrorMessages.SESSION_NOT_FOUND);\n      }\n\n      if (!req.session.authorizationCodeRequest) {\n        this.logger.error(ErrorMessages.AUTH_CODE_REQUEST_OBJECT_NOT_FOUND);\n        throw new Error(ErrorMessages.AUTH_CODE_REQUEST_OBJECT_NOT_FOUND);\n      }\n\n      if (!this.appSettings.authRoutes) {\n        this.logger.error(\n          ConfigurationErrorMessages.AUTH_ROUTES_NOT_CONFIGURED\n        );\n        throw new Error(ConfigurationErrorMessages.AUTH_ROUTES_NOT_CONFIGURED);\n      }\n\n      if (req.body.state) {\n        const state: AppState = JSON.parse(\n          this.cryptoUtils.decryptData(\n            this.cryptoProvider.base64Decode(req.body.state as string),\n            Buffer.from(req.session.key, 'hex')\n          )\n        );\n\n        // check if csrfToken matches\n        if (state.csrfToken === req.session.csrfToken) {\n          switch (state.appStage) {\n            case AppStages.SIGN_IN: {\n              // token request should have auth code\n              req.session.authorizationCodeRequest.code = req.body\n                .code as string;\n\n              try {\n                // exchange auth code for tokens\n                const tokenResponse = await this.msalClient.acquireTokenByCode(\n                  req.session.authorizationCodeRequest\n                );\n\n                if (!tokenResponse)\n                  throw new Error(ErrorMessages.TOKEN_RESPONSE_NULL);\n\n                req.session.isAuthenticated = true;\n                req.session.account = tokenResponse.account!; // this won't be null in any web app scenario\n                res.redirect(state.redirectTo);\n              } catch (error) {\n                next(error);\n              }\n              break;\n            }\n\n            case AppStages.ACQUIRE_TOKEN: {\n              // get the name of the resource associated with scope\n              const resourceName = ConfigHelper.getResourceNameFromScopes(\n                req.session.authorizationCodeRequest.scopes,\n                this.appSettings\n              );\n\n              req.session.authorizationCodeRequest.code = req.body\n                .code as string;\n\n              try {\n                const tokenResponse = await this.msalClient.acquireTokenByCode(\n                  req.session.authorizationCodeRequest\n                );\n\n                if (!tokenResponse)\n                  throw new Error(ErrorMessages.TOKEN_RESPONSE_NULL);\n\n                req.session.protectedResources = {\n                  [resourceName]: {\n                    accessToken: tokenResponse.accessToken,\n                  } as Resource,\n                };\n\n                res.redirect(state.redirectTo);\n              } catch (error) {\n                next(error);\n              }\n              break;\n            }\n\n            default:\n              next(new Error(ErrorMessages.CANNOT_DETERMINE_APP_STAGE));\n              break;\n          }\n        } else {\n          res.redirect(this.appSettings.authRoutes.unauthorized);\n        }\n      } else {\n        res.redirect(this.appSettings.authRoutes.unauthorized);\n      }\n    };\n  }\n\n  /**\n   * Middleware that gets tokens via acquireToken*\n   * @param {TokenRequestOptions} options: options to modify this middleware\n   * @returns {RequestHandler}\n   */\n  getToken(options: TokenRequestOptions): RequestHandler {\n    return async (\n      req: Request,\n      res: Response,\n      next: NextFunction\n    ): Promise<void> => {\n      if (!this.appSettings.protectedResources) {\n        this.logger.error(\n          ConfigurationErrorMessages.NO_PROTECTED_RESOURCE_CONFIGURED\n        );\n        throw new Error(\n          ConfigurationErrorMessages.NO_PROTECTED_RESOURCE_CONFIGURED\n        );\n      }\n\n      // get scopes for token request\n      const scopes = options.resource.scopes;\n      const resourceName = ConfigHelper.getResourceNameFromScopes(\n        scopes,\n        this.appSettings\n      );\n\n      req.session.protectedResources = {\n        [resourceName]: {\n          ...this.appSettings.protectedResources[resourceName],\n          accessToken: undefined,\n        } as Resource,\n      };\n\n      try {\n        const silentRequest = {\n          account: req.session.account,\n          scopes: scopes,\n        } as SilentFlowRequest;\n\n        // acquire token silently to be used in resource call\n        const tokenResponse = await this.msalClient.acquireTokenSilent(\n          silentRequest\n        );\n\n        if (!tokenResponse || StringUtils.isEmpty(tokenResponse.accessToken)) {\n          // In B2C scenarios, sometimes an access token is returned empty.\n          // In that case, we will acquire token interactively instead.\n\n          throw new InteractionRequiredAuthError(\n            ErrorMessages.INTERACTION_REQUIRED\n          );\n        }\n\n        req.session.protectedResources[resourceName].accessToken =\n          tokenResponse.accessToken;\n        next();\n      } catch (error) {\n        // in case there are no cached tokens, initiate an interactive call\n        if (error instanceof InteractionRequiredAuthError) {\n          const customState = {\n            appStage: AppStages.ACQUIRE_TOKEN,\n            redirectTo: req.originalUrl,\n          } as AppState;\n\n          const authUrlParams = {\n            scopes: scopes,\n          } as AuthorizationUrlRequest;\n\n          const authCodeParams = {\n            scopes: scopes,\n          } as AuthorizationCodeRequest;\n\n          // initiate the first leg of auth code grant to get token\n          return this.redirectToAuthCodeUrl(\n            req,\n            res,\n            next,\n            authUrlParams,\n            authCodeParams,\n            customState\n          );\n        } else {\n          next(error);\n        }\n      }\n    };\n  }\n\n  /**\n   * Check if authenticated in session\n   * @returns {RequestHandler}\n   */\n  isAuthenticated(): RequestHandler {\n    return (req: Request, res: Response, next: NextFunction): void => {\n      if (!this.appSettings.authRoutes) {\n        this.logger.error(\n          ConfigurationErrorMessages.AUTH_ROUTES_NOT_CONFIGURED\n        );\n        throw new Error(ConfigurationErrorMessages.AUTH_ROUTES_NOT_CONFIGURED);\n      }\n\n      if (!req.session.isAuthenticated) {\n        return res.redirect(this.appSettings.authRoutes.unauthorized);\n      }\n\n      next();\n    };\n  }\n\n  /**\n   * Checks if the user has access for this route, defined in access matrix\n   * @param {GuardOptions} options: options to modify this middleware\n   * @returns {RequestHandler}\n   */\n  hasAccess(options: GuardOptions): RequestHandler {\n    return async (\n      req: Request,\n      res: Response,\n      next: NextFunction\n    ): Promise<void> => {\n      if (!this.appSettings.authRoutes) {\n        this.logger.error(\n          ConfigurationErrorMessages.AUTH_ROUTES_NOT_CONFIGURED\n        );\n        throw new Error(ConfigurationErrorMessages.AUTH_ROUTES_NOT_CONFIGURED);\n      }\n\n      if (!this.appSettings.accessMatrix) {\n        this.logger.error(\n          ConfigurationErrorMessages.NO_ACCESS_MATRIX_CONFIGURED\n        );\n        throw new Error(ConfigurationErrorMessages.NO_ACCESS_MATRIX_CONFIGURED);\n      }\n\n      if (!req.session.account?.idTokenClaims) {\n        this.logger.error(ErrorMessages.ID_TOKEN_CLAIMS_NOT_FOUND);\n        throw new Error(ErrorMessages.ID_TOKEN_CLAIMS_NOT_FOUND);\n      }\n\n      const checkFor = options.accessRule.hasOwnProperty(\n        AccessControlConstants.GROUPS\n      )\n        ? AccessControlConstants.GROUPS\n        : AccessControlConstants.ROLES;\n\n      switch (checkFor) {\n        case AccessControlConstants.GROUPS:\n          if (\n            !req.session.account.idTokenClaims[AccessControlConstants.GROUPS]\n          ) {\n            if (\n              req.session.account.idTokenClaims[\n                AccessControlConstants.CLAIM_NAMES\n              ] ||\n              req.session.account.idTokenClaims[\n                AccessControlConstants.CLAIM_SOURCES\n              ]\n            ) {\n              return await this.handleOverage(\n                req,\n                res,\n                next,\n                options.accessRule\n              );\n            } else {\n              return res.redirect(this.appSettings.authRoutes.unauthorized);\n            }\n          } else {\n            const groups = req.session.account.idTokenClaims[\n              AccessControlConstants.GROUPS\n            ] as string[];\n\n            if (\n              !this.checkAccessRule(\n                req.method,\n                options.accessRule,\n                groups,\n                AccessControlConstants.GROUPS\n              )\n            ) {\n              return res.redirect(this.appSettings.authRoutes.unauthorized);\n            }\n          }\n\n          next();\n          break;\n\n        case AccessControlConstants.ROLES:\n          if (\n            !req.session.account.idTokenClaims[AccessControlConstants.ROLES]\n          ) {\n            return res.redirect(this.appSettings.authRoutes.unauthorized);\n          } else {\n            const roles = req.session.account.idTokenClaims[\n              AccessControlConstants.ROLES\n            ] as string[];\n\n            if (\n              !this.checkAccessRule(\n                req.method,\n                options.accessRule,\n                roles,\n                AccessControlConstants.ROLES\n              )\n            ) {\n              return res.redirect(this.appSettings.authRoutes.unauthorized);\n            }\n          }\n\n          next();\n          break;\n\n        default:\n          break;\n      }\n    };\n  }\n\n  // ============== UTILS ===============\n\n  /**\n   * This method is used to generate an auth code url request\n   * @param {Request} req: express request object\n   * @param {Response} res: express response object\n   * @param {NextFunction} next: express next function\n   * @param {AuthCodeParams} params: modifies auth code url request\n   * @returns {Promise}\n   */\n  private async redirectToAuthCodeUrl(\n    req: Request,\n    res: Response,\n    next: NextFunction,\n    authUrlParams: AuthorizationUrlRequest,\n    authCodeParams: AuthorizationCodeRequest,\n    customState: AppState\n  ): Promise<void> {\n    if (!this.appSettings.authRoutes) {\n      this.logger.error(ConfigurationErrorMessages.AUTH_ROUTES_NOT_CONFIGURED);\n      throw new Error(ConfigurationErrorMessages.AUTH_ROUTES_NOT_CONFIGURED);\n    }\n\n    // add session csrfToken for crsf\n    req.session.csrfToken = this.cryptoProvider.createNewGuid();\n\n    const key = this.cryptoUtils.createKey(\n      req.session.csrfToken,\n      this.cryptoUtils.generateSalt()\n    );\n    req.session.key = key.toString('hex');\n\n    const state = JSON.stringify({\n      ...customState,\n      csrfToken: req.session.csrfToken,\n    });\n\n    // prepare the request\n    req.session.authorizationUrlRequest = {\n      ...authUrlParams,\n      state: this.cryptoProvider.base64Encode(\n        this.cryptoUtils.encryptData(state, key)\n      ),\n      redirectUri: UrlUtils.ensureAbsoluteUrl(\n        req,\n        this.appSettings.authRoutes.redirect\n      ),\n      responseMode: ResponseMode.FORM_POST,\n    };\n\n    req.session.authorizationCodeRequest = {\n      ...authCodeParams,\n      redirectUri: UrlUtils.ensureAbsoluteUrl(\n        req,\n        this.appSettings.authRoutes.redirect\n      ),\n      code: '',\n    };\n\n    // request an authorization code to exchange for tokens\n    try {\n      const response = await this.msalClient.getAuthCodeUrl(\n        req.session.authorizationUrlRequest\n      );\n      res.redirect(response);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * Handles group overage claims by querying MS Graph /memberOf endpoint\n   * @param {Request} req: express request object\n   * @param {Response} res: express response object\n   * @param {NextFunction} next: express next function\n   * @param {AccessRule} rule: a given access rule\n   * @returns {Promise}\n   */\n  private async handleOverage(\n    req: Request,\n    res: Response,\n    next: NextFunction,\n    rule: AccessRule\n  ): Promise<void> {\n    if (!this.appSettings.authRoutes) {\n      this.logger.error(ConfigurationErrorMessages.AUTH_ROUTES_NOT_CONFIGURED);\n      throw new Error(ConfigurationErrorMessages.AUTH_ROUTES_NOT_CONFIGURED);\n    }\n\n    if (!req.session.account?.idTokenClaims) {\n      this.logger.error(ErrorMessages.ID_TOKEN_CLAIMS_NOT_FOUND);\n      throw new Error(ErrorMessages.ID_TOKEN_CLAIMS_NOT_FOUND);\n    }\n\n    const { _claim_names, _claim_sources, ...newIdTokenClaims } =\n      req.session.account.idTokenClaims;\n\n    const silentRequest: SilentFlowRequest = {\n      account: req.session.account,\n      scopes: AccessControlConstants.GRAPH_MEMBER_SCOPES.split(' '),\n    };\n\n    try {\n      // acquire token silently to be used in resource call\n      const tokenResponse = await this.msalClient.acquireTokenSilent(\n        silentRequest\n      );\n\n      if (!tokenResponse) throw new Error(ErrorMessages.TOKEN_RESPONSE_NULL);\n\n      try {\n        const graphResponse = await FetchManager.callApiEndpointWithToken(\n          AccessControlConstants.GRAPH_MEMBERS_ENDPOINT,\n          tokenResponse.accessToken\n        );\n\n        /**\n         * Some queries against Microsoft Graph return multiple pages of data either due to server-side paging\n         * or due to the use of the $top query parameter to specifically limit the page size in a request.\n         * When a result set spans multiple pages, Microsoft Graph returns an @odata.nextLink property in\n         * the response that contains a URL to the next page of results. Learn more at https://docs.microsoft.com/graph/paging\n         */\n        if (graphResponse.data[AccessControlConstants.PAGINATION_LINK]) {\n          try {\n            const userGroups = await FetchManager.handlePagination(\n              tokenResponse.accessToken,\n              graphResponse.data[AccessControlConstants.PAGINATION_LINK]\n            );\n\n            req.session.account.idTokenClaims = {\n              ...newIdTokenClaims,\n              groups: userGroups,\n            };\n\n            if (\n              !this.checkAccessRule(\n                req.method,\n                rule,\n                req.session.account.idTokenClaims[\n                  AccessControlConstants.GROUPS\n                ] as string[],\n                AccessControlConstants.GROUPS\n              )\n            ) {\n              return res.redirect(this.appSettings.authRoutes.unauthorized);\n            } else {\n              return next();\n            }\n          } catch (error) {\n            next(error);\n          }\n        } else {\n          req.session.account.idTokenClaims = {\n            ...newIdTokenClaims,\n            groups: graphResponse.data['value'].map((v: any) => v.id),\n          };\n\n          if (\n            !this.checkAccessRule(\n              req.method,\n              rule,\n              req.session.account.idTokenClaims[\n                AccessControlConstants.GROUPS\n              ] as string[],\n              AccessControlConstants.GROUPS\n            )\n          ) {\n            return res.redirect(this.appSettings.authRoutes.unauthorized);\n          } else {\n            return next();\n          }\n        }\n      } catch (error) {\n        next(error);\n      }\n    } catch (error) {\n      // TODO: handle silent token acquisition error\n      next(error);\n    }\n  }\n\n  /**\n   * Checks if the request passes a given access rule\n   * @param {string} method: HTTP method for this route\n   * @param {AccessRule} rule: access rule for this route\n   * @param {Array} creds: user's credentials i.e. roles or groups\n   * @param {string} credType: roles or groups\n   * @returns {boolean}\n   */\n  private checkAccessRule(\n    method: string,\n    rule: AccessRule,\n    creds: string[],\n    credType: string\n  ): boolean {\n    if (rule.methods.includes(method)) {\n      switch (credType) {\n        case AccessControlConstants.GROUPS:\n          if (rule.groups!.filter((elem) => creds.includes(elem)).length < 1) {\n            return false;\n          }\n          break;\n\n        case AccessControlConstants.ROLES:\n          if (rule.roles!.filter((elem) => creds.includes(elem)).length < 1) {\n            return false;\n          }\n          break;\n\n        default:\n          break;\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport express, {\n  Router,\n  RequestHandler,\n  Request,\n  Response,\n  NextFunction,\n} from 'express';\n\nimport { AccountInfo, AuthToken } from '@azure/msal-common';\n\nimport { BaseAuthClient } from '../BaseAuthClient';\nimport { Configuration } from '@azure/msal-node';\n\nimport { AccessTokenClaims, IdTokenClaims } from '../../utils/Types';\nimport { AppSettings, Resource } from '../../config/AppSettings';\nimport { ConfigHelper } from '../../config/ConfigHelper';\nimport { UrlUtils } from '../../utils/UrlUtils';\n\nimport {\n  SignInOptions,\n  SignOutOptions,\n  TokenRequestOptions,\n} from '../MiddlewareOptions';\n\nimport {\n  AppServiceAuthenticationHeaders,\n  AppServiceEnvironmentVariables,\n  AppServiceAuthenticationEndpoints,\n  AppServiceAuthenticationQueryParameters,\n  ErrorMessages,\n  ConfigurationErrorMessages,\n} from '../../utils/Constants';\n\nexport class AppServiceWebAppAuthClient extends BaseAuthClient {\n  /**\n   * @param {AppSettings} appSettings\n   * @param {Configuration} msalConfig\n   * @constructor\n   */\n  constructor(appSettings: AppSettings, msalConfig: Configuration) {\n    super(appSettings, msalConfig);\n  }\n\n  /**\n   * Initialize AuthProvider and set default routes and handlers\n   * @param {InitializationOptions} options\n   * @returns {Router}\n   */\n  initialize(): Router {\n    if (!this.appSettings.authRoutes) {\n      this.logger.error(ConfigurationErrorMessages.AUTH_ROUTES_NOT_CONFIGURED);\n      throw new Error(ConfigurationErrorMessages.AUTH_ROUTES_NOT_CONFIGURED);\n    }\n\n    const appRouter = express.Router();\n\n    // handle redirect\n    appRouter.get(\n      UrlUtils.getPathFromUrl(this.appSettings.authRoutes.redirect),\n      this.handleRedirect()\n    );\n    appRouter.post(\n      UrlUtils.getPathFromUrl(this.appSettings.authRoutes.redirect),\n      this.handleRedirect()\n    );\n\n    appRouter.use((req: Request, res: Response, next: NextFunction): void => {\n      if (!req.session) {\n        this.logger.error(ErrorMessages.SESSION_NOT_FOUND);\n        throw new Error(ErrorMessages.SESSION_NOT_FOUND);\n      }\n\n      if (!req.session.isAuthenticated) {\n        // check headers for id token\n        const rawIdToken = req.headers[\n          AppServiceAuthenticationHeaders.APP_SERVICE_ID_TOKEN_HEADER.toLowerCase()\n        ] as string;\n\n        if (rawIdToken) {\n          // parse the id token\n          const idTokenClaims: IdTokenClaims = AuthToken.extractTokenClaims(\n            rawIdToken,\n            this.cryptoProvider\n          );\n\n          req.session.isAuthenticated = true;\n\n          req.session.account = {\n            tenantId: idTokenClaims.tid,\n            homeAccountId: idTokenClaims.oid + '.' + idTokenClaims.tid,\n            localAccountId: idTokenClaims.oid,\n            environment: idTokenClaims.iss?.split('://')[1].split('/')[0],\n            username: idTokenClaims.preferred_username,\n            name: idTokenClaims.name,\n            idTokenClaims: idTokenClaims,\n          } as AccountInfo;\n        }\n      }\n\n      next();\n    });\n\n    return appRouter;\n  }\n\n  /**\n   * Initiates sign in flow\n   * @param {SignInOptions} options: options to modify login request\n   * @returns {RequestHandler}\n   */\n  signIn(\n    options: SignInOptions = {\n      postLoginRedirect: '/',\n      failureRedirect: '/',\n    }\n  ): RequestHandler {\n    return (req: Request, res: Response, next: NextFunction): void => {\n      let loginUri;\n      const postLoginRedirectUri = UrlUtils.ensureAbsoluteUrl(\n        req,\n        options.postLoginRedirect\n      );\n      loginUri =\n        'https://' +\n        process.env[AppServiceEnvironmentVariables.WEBSITE_HOSTNAME] +\n        AppServiceAuthenticationEndpoints.AAD_SIGN_IN_ENDPOINT +\n        AppServiceAuthenticationQueryParameters.POST_LOGIN_REDIRECT_QUERY_PARAM +\n        postLoginRedirectUri;\n      res.redirect(loginUri);\n    };\n  }\n\n  /**\n   * Initiate sign out and destroy the session\n   * @param {SignOutOptions} options: options to modify logout request\n   * @returns {RequestHandler}\n   */\n  signOut(\n    options: SignOutOptions = {\n      postLogoutRedirect: '/',\n    }\n  ): RequestHandler {\n    return (req: Request, res: Response, next: NextFunction): void => {\n      const postLogoutRedirectUri = UrlUtils.ensureAbsoluteUrl(\n        req,\n        options.postLogoutRedirect\n      );\n      const logoutUri =\n        'https://' +\n        process.env[AppServiceEnvironmentVariables.WEBSITE_HOSTNAME] +\n        AppServiceAuthenticationEndpoints.AAD_SIGN_OUT_ENDPOINT +\n        AppServiceAuthenticationQueryParameters.POST_LOGOUT_REDIRECT_QUERY_PARAM +\n        postLogoutRedirectUri;\n\n      req.session.destroy(() => {\n        res.redirect(logoutUri);\n      });\n    };\n  }\n\n  /**\n   * Middleware that handles redirect depending on request state\n   * There are basically 2 stages: sign-in and acquire token\n   * @returns {RequestHandler}\n   */\n  private handleRedirect(): RequestHandler {\n    return async (\n      req: Request,\n      res: Response,\n      next: NextFunction\n    ): Promise<void> => {\n      next();\n    };\n  }\n\n  /**\n   * Middleware that gets tokens\n   * @param {TokenRequestOptions} options: options to modify this middleware\n   * @returns {RequestHandler}\n   */\n  getToken(options: TokenRequestOptions): RequestHandler {\n    return async (\n      req: Request,\n      res: Response,\n      next: NextFunction\n    ): Promise<void> => {\n      // get scopes for token request\n      const resourceName = ConfigHelper.getResourceNameFromScopes(\n        options.resource.scopes,\n        this.appSettings\n      );\n\n      if (!req.session.protectedResources) {\n        req.session.protectedResources = {};\n      }\n\n      req.session.protectedResources = {\n        [resourceName]: {\n          ...this.appSettings.protectedResources![resourceName],\n          accessToken: undefined,\n        } as Resource,\n      };\n\n      const rawAccessToken = req.headers[\n        AppServiceAuthenticationHeaders.APP_SERVICE_ACCESS_TOKEN_HEADER.toLowerCase()\n      ] as string;\n\n      if (rawAccessToken) {\n        const accessTokenClaims = AuthToken.extractTokenClaims(\n          rawAccessToken,\n          this.cryptoProvider\n        ) as AccessTokenClaims;\n\n        // get the name of the resource associated with scope\n        const scopes = accessTokenClaims?.scp.split(' ');\n        const effectiveScopes = ConfigHelper.getEffectiveScopes(scopes);\n\n        if (\n          options.resource.scopes.every((elem) =>\n            effectiveScopes.includes(elem)\n          )\n        ) {\n          req.session.protectedResources[resourceName].accessToken =\n            rawAccessToken;\n          return next();\n        } else {\n          return next(new Error('No tokens found for given scopes'));\n        }\n      }\n    };\n  }\n\n  /**\n   * Check if authenticated in session\n   * @returns {RequestHandler}\n   */\n  isAuthenticated(): RequestHandler {\n    return (req: Request, res: Response, next: NextFunction): void => {\n      if (!req.session.isAuthenticated) {\n        return res.redirect(this.appSettings.authRoutes!.unauthorized);\n      }\n\n      next();\n    };\n  }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { DefaultAzureCredential } from '@azure/identity';\nimport {\n    CertificateClient,\n    KeyVaultCertificate,\n} from '@azure/keyvault-certificates';\nimport { KeyVaultSecret, SecretClient } from '@azure/keyvault-secrets';\n\nimport { KeyVaultCredential, ClientCertificate } from '../config/AppSettings';\nimport { KeyVaultCredentialTypes } from '../utils/Constants';\n\nexport type KeyVaultCredentialResponse = {\n    type: KeyVaultCredentialTypes.SECRET | KeyVaultCredentialTypes.CERTIFICATE;\n    value: string & ClientCertificate;\n};\n\nexport class KeyVaultManager {\n    /**\n     * Fetches credentials from Key Vault and updates appSettings\n     * @param {AppSettings} appSettings\n     * @returns {Promise}\n     */\n    async getCredentialFromKeyVault(\n        keyVaultCredential: KeyVaultCredential\n    ): Promise<KeyVaultCredentialResponse> {\n        const credential = new DefaultAzureCredential();\n        let response: KeyVaultCredentialResponse = {} as KeyVaultCredentialResponse;\n\n        switch (keyVaultCredential.credentialType) {\n            case KeyVaultCredentialTypes.SECRET: {\n                try {\n                    const secretResponse = await this.getSecretCredential(\n                        keyVaultCredential,\n                        credential\n                    );\n\n                    response = {\n                        type: KeyVaultCredentialTypes.SECRET,\n                        value: secretResponse.value,\n                    } as KeyVaultCredentialResponse;\n                } catch (error) {\n                    throw error;\n                }\n                break;\n            }\n\n            case KeyVaultCredentialTypes.CERTIFICATE: {\n                try {\n                    const certificateResponse = await this.getCertificateCredential(\n                        keyVaultCredential,\n                        credential\n                    );\n                    const secretResponse = await this.getSecretCredential(\n                        keyVaultCredential,\n                        credential\n                    );\n\n                    response = {\n                        type: KeyVaultCredentialTypes.CERTIFICATE,\n                        value: {\n                            thumbprint:\n                                certificateResponse?.properties?.x509Thumbprint?.toString(),\n                            privateKey: secretResponse?.value?.split(\n                                '-----BEGIN CERTIFICATE-----\\n'\n                            )[0],\n                        },\n                    } as KeyVaultCredentialResponse;\n                } catch (error) {\n                    throw error;\n                }\n                break;\n            }\n\n            default:\n                break;\n        }\n\n        return response;\n    }\n\n    /**\n     * Gets a certificate credential from Key Vault\n     * @param {AppSettings} config\n     * @param {DefaultAzureCredential} credential\n     * @returns {Promise}\n     */\n    async getCertificateCredential(\n        keyVaultCredential: KeyVaultCredential,\n        credential: DefaultAzureCredential\n    ): Promise<KeyVaultCertificate> {\n        // Initialize secretClient with credentials\n        const secretClient = new CertificateClient(\n            keyVaultCredential.keyVaultUrl,\n            credential\n        );\n\n        try {\n            const keyVaultCertificate = await secretClient.getCertificate(\n                keyVaultCredential.credentialName\n            );\n            return keyVaultCertificate;\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    /**\n     * Gets a secret credential from Key Vault\n     * @param {AppSettings} config\n     * @param {DefaultAzureCredential} credential\n     * @returns {Promise}\n     */\n    async getSecretCredential(\n        keyVaultCredential: KeyVaultCredential,\n        credential: DefaultAzureCredential\n    ): Promise<KeyVaultSecret> {\n        // Initialize secretClient with credentials\n        const secretClient = new SecretClient(\n            keyVaultCredential.keyVaultUrl,\n            credential\n        );\n\n        try {\n            const keyVaultSecret = await secretClient.getSecret(\n                keyVaultCredential.credentialName\n            );\n            return keyVaultSecret;\n        } catch (error) {\n            throw error;\n        }\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { UrlString, Constants } from '@azure/msal-common';\n\nimport { Configuration } from '@azure/msal-node';\n\nimport { DEFAULT_LOGGER_OPTIONS } from '../utils/Constants';\n\nimport { AppSettings } from './AppSettings';\n\nexport class MsalConfiguration {\n    /**\n     * Maps the custom configuration object to configuration\n     * object expected by MSAL Node ConfidentialClientApplication class\n     * @param {AppSettings} appSettings: configuration object\n     * @param {ICachePlugin} cachePlugin: custom cache plugin\n     * @param {IDistributedPersistence} distributedPersistence: distributed persistence client\n     * @returns {Configuration}\n     */\n    static getMsalConfiguration(appSettings: AppSettings): Configuration {\n        return {\n            auth: {\n                clientId: appSettings.appCredentials.clientId,\n                authority: appSettings.b2cPolicies\n                    ? Object.entries(appSettings.b2cPolicies)[0][1]['authority'] // the first policy/user-flow is the default authority\n                    : appSettings.appCredentials.instance\n                        ? `https://${appSettings.appCredentials.instance}/${appSettings.appCredentials.tenantId}`\n                        : `https://${Constants.DEFAULT_AUTHORITY_HOST}/${appSettings.appCredentials.tenantId}`,\n                ...(appSettings.appCredentials.hasOwnProperty('clientSecret') && {\n                    clientSecret: appSettings.appCredentials.clientSecret,\n                }),\n                ...(appSettings.appCredentials.hasOwnProperty('clientCertificate') && {\n                    clientCertificate: appSettings.appCredentials.clientCertificate,\n                }),\n                knownAuthorities: appSettings.b2cPolicies\n                    ? [\n                        UrlString.getDomainFromUrl(\n                            Object.entries(appSettings.b2cPolicies)[0][1]['authority']\n                        ),\n                    ] // in B2C scenarios\n                    : [],\n            },\n            system: {\n                loggerOptions: appSettings.loggerOptions\n                    ? appSettings.loggerOptions\n                    : DEFAULT_LOGGER_OPTIONS,\n            },\n        };\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AppServiceEnvironmentVariables } from './Constants';\n\nexport class EnvironmentUtils {\n  static isProduction(): boolean {\n    return process.env.NODE_ENV === 'production';\n  }\n\n  static isDevelopment(): boolean {\n    return process.env.NODE_ENV === 'development';\n  }\n\n  static isAppServiceAuthEnabled(): boolean {\n    return (\n      process.env[AppServiceEnvironmentVariables.WEBSITE_AUTH_ENABLED] ===\n      'True'\n    );\n  }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Configuration } from '@azure/msal-node';\n\nimport { BaseAuthClientBuilder } from '../BaseAuthClientBuilder';\nimport { MsalWebAppAuthClient } from './MsalWebAppAuthClient';\nimport { AppServiceWebAppAuthClient } from './AppServiceWebAppAuthClient';\nimport { KeyVaultManager } from '../../network/KeyVaultManager';\nimport { MsalConfiguration } from '../../config/MsalConfiguration';\nimport { AppSettings, AppType } from '../../config/AppSettings';\nimport { EnvironmentUtils } from '../../utils/EnvironmentUtils';\nimport { ErrorMessages } from '../../utils/Constants';\n\nexport class WebAppAuthClientBuilder extends BaseAuthClientBuilder {\n  appSettings!: AppSettings;\n  private msalConfig!: Configuration;\n\n  constructor(appSettings: AppSettings) {\n    super(appSettings, AppType.WebApp);\n  }\n\n  build(): MsalWebAppAuthClient | AppServiceWebAppAuthClient {\n    // TODO: throw error if key vault credential is being built\n\n    this.msalConfig = MsalConfiguration.getMsalConfiguration(this.appSettings);\n\n    if (EnvironmentUtils.isAppServiceAuthEnabled()) {\n      return new AppServiceWebAppAuthClient(this.appSettings, this.msalConfig);\n    } else {\n      return new MsalWebAppAuthClient(this.appSettings, this.msalConfig);\n    }\n  }\n\n  async buildAsync(): Promise<\n    MsalWebAppAuthClient | AppServiceWebAppAuthClient\n  > {\n    try {\n      if (this.keyVaultCredential) {\n        const keyVaultManager = new KeyVaultManager();\n        const credential = await keyVaultManager.getCredentialFromKeyVault(\n          this.keyVaultCredential\n        );\n        this.appSettings.appCredentials[credential.type] = credential.value;\n      }\n\n      this.msalConfig = MsalConfiguration.getMsalConfiguration(\n        this.appSettings\n      );\n\n      if (EnvironmentUtils.isAppServiceAuthEnabled()) {\n        return new AppServiceWebAppAuthClient(\n          this.appSettings,\n          this.msalConfig\n        );\n      } else {\n        return new MsalWebAppAuthClient(this.appSettings, this.msalConfig);\n      }\n    } catch (error) {\n      throw new Error(ErrorMessages.CANNOT_OBTAIN_CREDENTIALS_FROM_KEY_VAULT);\n    }\n  }\n}\n"],"names":["AppStages","KeyVaultCredentialTypes","AADAuthorityConstants","COMMON","ORGANIZATIONS","CONSUMERS","AppType","OIDC_SCOPES","AppServiceAuthenticationHeaders","APP_SERVICE_AUTHENTICATION_HEADER","APP_SERVICE_ACCESS_TOKEN_HEADER","APP_SERVICE_ID_TOKEN_HEADER","APP_SERVICE_REFRESH_TOKEN_HEADER","APP_SERVICE_ACCESS_TOKEN_EXPIRES_HEADER","APP_SERVICE_USER_OID_HEADER","APP_SERVICE_USER_UPN_HEADER","APP_SERVICE_IDP_X_HEADER","AccessControlConstants","GROUPS","ROLES","CLAIM_NAMES","CLAIM_SOURCES","PAGINATION_LINK","GRAPH_MEMBERS_ENDPOINT","GRAPH_MEMBER_SCOPES","ConfigurationErrorMessages","DEFAULT_LOGGER_OPTIONS","loggerCallback","logLevel","message","containsPii","console","info","piiLoggingEnabled","LogLevel","Info","ConfigHelper","validateAppSettings","appSettings","appType","StringUtils","isEmpty","appCredentials","clientId","Error","isGuid","tenantId","Object","values","includes","WebApp","authRoutes","_appSettings$authRout","redirect","_appSettings$authRout2","unauthorized","guid","test","getResourceNameFromScopes","scopes","index","protectedResources","ownedResources","findIndex","resource","JSON","stringify","keys","getScopesFromResourceEndpoint","resourceEndpoint","find","endpoint","_Object$values$find","getEffectiveScopes","scopesList","filter","scope","BaseAuthClientBuilder","this","_proto","withKeyVaultCredentials","keyVaultCredential","withCustomCachePlugin","cachePlugin","customCachePlugin","CryptoUtils","algorithm","generateSalt","crypto","toString","createKey","password","salt","encryptData","stringifiedData","key","iv","cipher","encryptedData","update","join","decryptData","split","encrypted","decipher","Buffer","from","BaseAuthClient","msalConfig","cryptoProvider","CryptoProvider","cryptoUtils","logger","Logger","system","_this$msalConfig$syst","loggerOptions","msalClient","ConfidentialClientApplication","getMsalClient","getMsalConfig","getLogger","FetchManager","_context","axios","get","data","accessToken","_context2","options","headers","Authorization","nextPage","_context3","callApiEndpointWithToken","graphResponse","map","v","push","id","handlePagination","UrlUtils","req","url","urlComponents","UrlString","getUrlComponents","Protocol","HostNameAndPort","startsWith","protocol","PathSegments","MsalWebAppAuthClient","_BaseAuthClient","_inheritsLoose","initialize","error","appRouter","express","Router","use","res","next","session","_this","post","getPathFromUrl","handleRedirect","_this$appSettings$aut","frontChannelLogout","destroy","sendStatus","signIn","postLoginRedirect","failureRedirect","_this2","redirectToAuthCodeUrl","OIDC_DEFAULT_SCOPES","appStage","SIGN_IN","redirectTo","csrfToken","signOut","postLogoutRedirect","postLogoutRedirectUri","ensureAbsoluteUrl","logoutUri","_this3","auth","authority","_this4","authorizationCodeRequest","body","state","parse","base64Decode","ACQUIRE_TOKEN","code","acquireTokenByCode","tokenResponse","isAuthenticated","account","resourceName","getToken","_this5","undefined","silentRequest","acquireTokenSilent","InteractionRequiredAuthError","originalUrl","_this6","hasAccess","_this7","accessMatrix","_req$session$account","idTokenClaims","checkFor","accessRule","hasOwnProperty","handleOverage","checkAccessRule","method","authUrlParams","authCodeParams","customState","_context4","createNewGuid","authorizationUrlRequest","base64Encode","redirectUri","responseMode","ResponseMode","FORM_POST","getAuthCodeUrl","rule","_context5","_req$session$account2","_claim_names","newIdTokenClaims","groups","creds","credType","methods","elem","length","roles","AppServiceWebAppAuthClient","rawIdToken","toLowerCase","AuthToken","extractTokenClaims","tid","homeAccountId","oid","localAccountId","environment","iss","_idTokenClaims$iss","username","preferred_username","name","loginUri","postLoginRedirectUri","process","env","rawAccessToken","accessTokenClaims","scp","effectiveScopes","every","KeyVaultManager","getCredentialFromKeyVault","credential","DefaultAzureCredential","response","credentialType","SECRET","CERTIFICATE","getSecretCredential","type","value","getCertificateCredential","certificateResponse","secretResponse","thumbprint","properties","_certificateResponse$","x509Thumbprint","_certificateResponse$2","privateKey","_secretResponse$value","secretClient","CertificateClient","keyVaultUrl","getCertificate","credentialName","SecretClient","getSecret","MsalConfiguration","getMsalConfiguration","b2cPolicies","entries","instance","Constants","DEFAULT_AUTHORITY_HOST","clientSecret","clientCertificate","knownAuthorities","getDomainFromUrl","EnvironmentUtils","isProduction","isDevelopment","isAppServiceAuthEnabled","WebAppAuthClientBuilder","_BaseAuthClientBuilde","build","buildAsync","keyVaultManager"],"mappings":"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"}